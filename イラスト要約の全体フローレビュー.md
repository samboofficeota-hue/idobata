# イラスト要約の全体フローレビュー

## 1. ユーザーからの回答 → データ保存

### フロー
1. **ユーザーがチャットで意見を投稿**
   - ファイル: `idea-discussion/backend/controllers/chatController.js`
   - チャットメッセージが保存される

2. **AIが意見からProblem/Solutionを抽出**
   - ファイル: `idea-discussion/backend/workers/extractionWorker.js`
   - `Problem`モデルと`Solution`モデルに保存
   - `statement`フィールドに課題/解決策のテキストが保存される

3. **QuestionLinkで関連付け**
   - ファイル: `idea-discussion/backend/models/QuestionLink.js`
   - `questionId`と`linkedItemId`（Problem/SolutionのID）で関連付け
   - `relevanceScore`で関連度を記録

### データ構造
- **Problem**: `{ _id, statement, sourceType, sourceOriginId, ... }`
- **Solution**: `{ _id, statement, sourceType, sourceOriginId, ... }`
- **QuestionLink**: `{ questionId, linkedItemId, linkedItemType, relevanceScore }`

---

## 2. AIへのインプット

### ファイル
`idea-discussion/backend/services/questionVisualReportGenerator.js`

### データ取得（15-64行目）
```javascript
// 1. Questionを取得
const question = await SharpQuestion.findById(questionId);
// question.questionText が使用される

// 2. QuestionLinkから関連するProblem/SolutionのIDを取得
const links = await QuestionLink.find({ questionId: questionId });
const problemLinks = links.filter(link => link.linkedItemType === "problem");
const solutionLinks = links.filter(link => link.linkedItemType === "solution");

// 3. relevanceScoreでソート
problemLinks.sort((a, b) => (b.relevanceScore || 0) - (a.relevanceScore || 0));
solutionLinks.sort((a, b) => (b.relevanceScore || 0) - (a.relevanceScore || 0));

// 4. Problem/Solutionのstatementを取得
const problemStatements = sortedProblems.map((p) => p.statement);
const solutionStatements = sortedSolutions.map((s) => s.statement);
```

### Markdownコンテンツ生成（66-74行目）
```javascript
const markdownContent = `
# ${question.questionText}

## 課題点
${problemStatements.map((statement, index) => `${index + 1}. ${statement}`).join("\n")}

## 解決策
${solutionStatements.map((statement, index) => `${index + 1}. ${statement}`).join("\n")}
`;
```

### プロンプト生成（76-149行目）
- **ヘッダー仕様**: 右上に小さく「（今日の日付）／（問いのタイトル）」
- **フッター仕様**: 「idobata by DD2030」
- **問いのタイトル**: `${question.questionText}`を使用（146行目）

### LLM呼び出し（154-158行目）
```javascript
const completion = await callLLM(
  [{ role: "user", content: visualPrompt }],
  false,  // JSON出力ではない
  "gpt-5-mini"
);
```

---

## 3. AIからのアウトプット → データ保存

### HTML処理（164行目）
```javascript
const overallAnalysis = completion.replace(/^```html|```$/g, "").trim();
```
- LLMが返すHTMLコードブロック（```html ... ```）を除去

### データベース保存（174-184行目）
```javascript
const newVisualReport = new QuestionVisualReport({
  questionId: question._id,
  questionText: question.questionText,
  overallAnalysis,  // ← HTMLコンテンツがここに保存
  sourceProblemIds: problemIds,
  sourceSolutionIds: solutionIds,
  version: nextVersion,
});
await newVisualReport.save();
```

### データモデル
**ファイル**: `idea-discussion/backend/models/QuestionVisualReport.js`
- `overallAnalysis`: String型（HTMLコンテンツ）
- `questionId`: ObjectId（関連する質問）
- `version`: Number（バージョン管理）

---

## 4. 表示実装

### バックエンドAPI

#### 取得API
**ファイル**: `idea-discussion/backend/controllers/questionController.js`
**行数**: 182行目、252行目

```javascript
// 182行目: データ取得
const visualReport = await getQuestionVisualReport(questionId);

// 252行目: レスポンス
visualReport: visualReport ? visualReport.overallAnalysis : null,
```

**APIエンドポイント**: `GET /api/themes/:themeId/questions/:questionId`
**レスポンス**: `{ ..., visualReport: string | null }`

#### 生成トリガーAPI
**ファイル**: `idea-discussion/backend/controllers/questionController.js`
**行数**: 442-483行目

```javascript
// POST /api/themes/:themeId/questions/:questionId/generate-visual-report
export const triggerVisualReportGeneration = async (req, res) => {
  // ...
  setTimeout(() => {
    generateVisualReport(questionId).catch((err) => {
      // エラーハンドリング
    });
  }, 0);
  // ...
};
```

### フロントエンド

#### データ取得
**ファイル**: `frontend/src/hooks/useQuestionDetail.ts`
**行数**: 27行目、43行目

```typescript
// 型定義
visualReport: string;  // ← overallAnalysisがここにマッピング

// API呼び出し
const result = await apiClient.getQuestionDetails(questionId, themeId);
```

**ファイル**: `frontend/src/services/api/apiClient.ts`
- `getQuestionDetails`メソッドでAPIを呼び出し

#### 表示コンポーネント

**IllustrationSummaryContent.tsx**（15-30行目）
```tsx
// HTMLコンテンツの場合
if (visualReport.includes("<!DOCTYPE html>") || visualReport.includes("<html")) {
  return (
    <div className="w-full h-[600px] md:h-[800px]">
      <iframe
        srcDoc={visualReport}  // ← overallAnalysisがここに渡される
        className="w-full h-full border-0 rounded-2xl"
        title="イラスト要約"
        sandbox="allow-same-origin allow-scripts"
      />
    </div>
  );
}
```

**IllustrationReportCard.tsx**（57-61行目）
```tsx
<div className={`${isExpanded ? "h-auto" : "h-[200px] md:h-[280px]"} overflow-hidden flex justify-center items-center`}>
  {children}  // ← IllustrationSummaryContentがここに表示される
</div>
```

---

## 5. 矛盾・問題点の確認

### ✅ 正常な部分

1. **データフロー**: 問題なし
   - Problem/Solution → QuestionLink → VisualReport生成 → 表示

2. **フィールドマッピング**: 問題なし
   - `overallAnalysis` → `visualReport` → `srcDoc`で正しく渡されている

3. **型定義**: 問題なし
   - `visualReport: string`で正しく定義されている

### ⚠️ 潜在的な問題点

1. **プロンプトの日付指定**
   - **問題**: プロンプトで「今日の日付」と指定しているが、LLMが生成時に実際の日付を取得できない可能性
   - **影響**: ヘッダーに不正確な日付が表示される可能性
   - **推奨**: プロンプトに実際の日付を明示的に含める

2. **CSS設定の矛盾**
   - **プロンプト指定**: `margin: 0, padding: 2px`（132行目）
   - **フロントエンド表示**: iframeの`className="w-full h-full border-0 rounded-2xl"`
   - **問題**: iframe内のHTMLのmargin/paddingと、iframe外のスタイルが競合する可能性は低い（iframeは独立したドキュメント）

3. **高さの指定**
   - **プロンプト指定**: `高さは1440px以上`（118行目）
   - **フロントエンド表示**: `h-[600px] md:h-[800px]`（固定高さ）
   - **問題**: 生成されるHTMLが1440px以上でも、iframeで600-800pxに制限される
   - **影響**: スクロールが必要になる可能性

4. **幅の指定**
   - **プロンプト指定**: `コンテンツの幅は375pxで中央揃え`（117行目）
   - **フロントエンド表示**: `w-full`（100%幅）
   - **問題**: 生成されるHTMLが375px幅でも、iframeが100%幅なので表示が崩れる可能性は低い（HTML内で中央揃えされているため）

5. **ダウンロード機能**
   - **問題**: HTMLコンテンツの場合、ダウンロードボタンが表示されない（253-263行目）
   - **影響**: ユーザーがHTMLコンテンツをダウンロードできない
   - **現状**: 画像URLの場合のみダウンロード可能

---

## 6. 推奨修正

### 修正1: プロンプトに実際の日付を追加
```javascript
const today = new Date();
const dateStr = `${today.getFullYear()}年${today.getMonth() + 1}月${today.getDate()}日`;

const visualPrompt = `
...
## 重要な注意事項
- ヘッダーには、右上に小さく「${dateStr}／${question.questionText}」を表示してください。
- フッターには「idobata by DD2030」を表示してください。
...
`;
```

### 修正2: iframeの高さを動的に調整（オプション）
生成されるHTMLの高さに応じてiframeの高さを調整するか、スクロール可能にする

### 修正3: HTMLコンテンツのダウンロード機能（オプション）
HTMLコンテンツを画像としてダウンロードできるようにする（html2canvasなど）

---

## 7. パス確認

### バックエンド
- ✅ `services/questionVisualReportGenerator.js` → `getVisualReport`関数
- ✅ `controllers/questionController.js` → `getQuestionDetails`で`getVisualReport`を呼び出し
- ✅ `routes/themeQuestionRoutes.js` → ルーティング設定

### フロントエンド
- ✅ `services/api/apiClient.ts` → `getQuestionDetails`メソッド
- ✅ `hooks/useQuestionDetail.ts` → `apiClient.getQuestionDetails`を呼び出し
- ✅ `pages/QuestionDetail.tsx` → `useQuestionDetail`フックを使用
- ✅ `components/question/IllustrationSummaryContent.tsx` → `visualReport`を表示
- ✅ `components/question/IllustrationReportCard.tsx` → カードコンテナ

---

## 8. CSS設定の確認

### プロンプトで指定されているCSS
- フォント: Zen Maru Gothic
- コンテンツ幅: 375px（中央揃え）
- 高さ: 1440px以上
- margin: 0
- padding: 2px

### フロントエンドのCSS
- iframe: `w-full h-[600px] md:h-[800px]`（固定高さ）
- カード: `bg-blue-50 border-4 border-white rounded-2xl`
- コンテンツエリア: `h-[200px] md:h-[280px]`（折りたたみ時）

### 矛盾点
- **高さ**: プロンプトは1440px以上を指定しているが、フロントエンドは600-800pxに制限
  - **影響**: スクロールが必要になる
  - **推奨**: iframe内でスクロール可能にするか、高さを動的に調整

---

## まとめ

### 正常に動作している部分
1. データフロー全体
2. APIエンドポイントとルーティング
3. フロントエンドのデータ取得と表示
4. フィールドマッピング

### 改善が必要な部分
1. **日付の明示的な指定**（プロンプトに実際の日付を含める）
2. **高さの制限**（iframeの高さと生成HTMLの高さの不一致）
3. **HTMLコンテンツのダウンロード機能**（現状は画像URLのみ）

### 重大な問題
なし。全体的に正常に動作しているが、上記の改善点を実装するとより良いUXになる。
